{
    "collab_server" : "",
    "contents" : "#Reading dataset\ndataset <- read.csv(\"kc_house_data.csv\")\nhouseData <- subset(dataset, select = c(\"price\",\"bedrooms\",\"bathrooms\",\"sqft_living\",\"sqft_lot\",\"floors\",\"waterfront\",\"view\",\"condition\",\"grade\",\"sqft_above\",\"sqft_basement\",\"yr_built\",\"yr_renovated\",\"zipcode\",\"lat\",\"long\",\"sqft_living15\",\"sqft_lot15\"))\n\n# Point number 1\nsummary(houseData$price)\nsd(houseData$price)\n\n# Point number 2\n# Partitioning dataset in 80% training data and 20% testing data.\n# 80% of the sample size\nsmp_size <- floor(0.80 * nrow(houseData))\n\n## set the seed to make your partition reproductible\nset.seed(20161101)\ntrain_sample <- sample(seq_len(nrow(houseData)), size = smp_size)\n\n#Obtaining training and test portions from house data\nhouse.Train <- houseData[train_sample, ]\nhouse.Test <- houseData[-train_sample, ]\n\n# 2.a cases in training data set\nnrow(house.Train)\n# 2.b cases in test data set\nnrow(house.Test)\n\n# 2.c\n  # Summary for Training set\nsummary(house.Train$price)\nsd(house.Train$price)\n  # Summary for Test set\nsummary(house.Test$price)\nsd(house.Test$price)\n\n# 2.d\n  # Fitting a multiple linear regression model\nhPrice.Tr.lm <- lm(price~., data=house.Train) \nsummary(hPrice.Tr.lm)\n#anova(house.Train.lm)\n\n# 2.e\n  # Use the automatic forward/backward selection method to derive the \\best\" model\nhPrice.null <- lm(price~ 1, data=house.Train) \nhousing.best <- stepAIC(hPrice.null, scope=list(upper=hPrice.Tr.lm,lower=hPrice.null),direction=\"both\")\nsummary(housing.best)\n\n# 2.f\n  # Draw scatterplots of the residuals in the \\best\" model against each of the predictors.\npar(mfrow=c(3,3))\ncrPlots(housing.best, line = TRUE, smooth = TRUE)\n\n# 2.g\n#---------------------------------------------------\n# Selected predictors with non-linear effects\n# sqft_living, bathrooms, sqft_above\n#---------------------------------------------------\n  #Creating 5-folds for crossvalidation\nk.smp_size <- (nrow(houseData) - smp_size)\n\n  #Fold k1\nk1 <- house.Test\nk2_sample <- sample(seq_len(nrow(house.Train)), size = k.smp_size)\n \n #Fold k2\nk2 <- house.Train[k2_sample, ]\nk345 <- house.Train[-k2_sample, ]\nk3_sample <- sample(seq_len(nrow(k345)), size = k.smp_size)\n \n #Fold k3\nk3 <- k345[k3_sample, ]\nk45 <- k345[-k3_sample, ]\nk4_sample <- sample(seq_len(nrow(k45)), size = k.smp_size)\n  \n#Fold k4\nk4 <- k45[k4_sample, ]\n \n #Fold k5\nk5 <- k45[-k4_sample, ]\n\n#function to calculate MSE\nmse_v <- function(testData,model){\n  MSE <- mean((testData$price-predict(model,testData))^2)\n  return(MSE)\n}\n\n# Linear model function for crossvalidation\nf.lm.crossV <- function(formula,kf.Train1,kf.Train2,kf.Train3,kf.Train4){\n  k.training <- rbind(kf.Train1,kf.Train2,kf.Train3,kf.Train4)\n  l.model <- lm(formula, data=k.training)\n  return(l.model)\n}\n\n#-------------------------------------------------------------------------------------sqft_living\n\n#vector to save the MSE of each cross fold validation for each polynomial of \"sqft_living\"\nMSE.Crsfld.sqft_living <- c(0,0,0,0,0)\n\n#vector to save the MSE of each polynomial for \"sqft_living\"\nMSE.Ply.sqft_living <- c(0,0,0,0,0)\n#---------------------------------------------------\n# For loop to perform iteratively cross validation for \"sqft_living\" \n# In the first loop, selection of the formula (polynomial) is achieved. In the nested\n# for loop cross validation and MSE of each k-test set is obtained and saved\n# in MSE.Crsfld.sqft_living vector, subsequently the mean of this variable is stored in\n# MSE.Ply.sqft_living this is for each polynomial.\n\nfor(i in 1:5){\n  formula.sqft_living <- lm(price ~. - floors - sqft_basement + poly(sqft_living, i), data=houseData)\n  for(j in 1:5){\n    if(j == 1){\n      lm.sqft_living <- f.lm.crossV(formula.sqft_living, k2, k3, k4, k5)\n      MSE.Crsfld.sqft_living[j] <- mse_v(k1,lm.sqft_living)\n    }\n    if(j == 2){\n      lm.sqft_living <- f.lm.crossV(formula.sqft_living, k1, k3, k4, k5)\n      MSE.Crsfld.sqft_living[j] <- mse_v(k2,lm.sqft_living)\n    }\n    if(j == 3){\n      lm.sqft_living <- f.lm.crossV(formula.sqft_living, k1, k2, k4, k5)\n      MSE.Crsfld.sqft_living[j] <- mse_v(k3,lm.sqft_living)\n    }\n    if(j == 4){\n      lm.sqft_living <- f.lm.crossV(formula.sqft_living, k1, k2, k3, k5)\n      MSE.Crsfld.sqft_living[j] <- mse_v(k4,lm.sqft_living)\n    }\n    if(j == 5){\n      lm.sqft_living <- f.lm.crossV(formula.sqft_living, k1, k2, k3, k4)\n      MSE.Crsfld.sqft_living[j] <- mse_v(k5,lm.sqft_living)\n    }\n  }\n  MSE.Ply.sqft_living[i] <- mean(MSE.Crsfld.sqft_living)\n}\n#View(MSE.Ply.sqft_living)\n#Vector to plot the order of the against the MSE\norder <- c(1,2,3,4,5)\n\n#Plot of the MSE for \"sqft_living\"\npar(mfrow=c(1,1))\nplot(order,MSE.Ply.sqft_living, type = \"o\", col = \"red\", lwd = 2, main = \"5-fold CV - sqft_living\", xlab = \"Degree of Polynomial\", ylab = \"Mean Squared Error\")\n\n#vector to save the MSE of each cross fold validation for each polynomial of \"bathrooms \"\nMSE.Crsfld.bathrooms <- c(0,0,0,0,0)\n\n#vector to save the MSE of each polynomial for \"bathrooms \"\nMSE.Ply.bathrooms <- c(0,0,0,0,0)\n#---------------------------------------------------\n# For loop to perform iteratively cross validation for \"bathrooms\" \n# In the first loop, selection of the formula (polynomial) is achieved. In the nested\n# for loop cross validation and MSE of each test set is obtained and saved\n# in MSE.Crsfld.bathrooms vector, subsequently the mean of this variable is stored in\n# MSE.Ply.bathrooms this is for each polynomial.\n\nfor(i in 1:5){\n  formula.bathrooms <- lm(price ~. - floors - sqft_basement + poly(bathrooms, i), data=houseData)\n  for(j in 1:5){\n    if(j == 1){\n      lm.bathrooms <- f.lm.crossV(formula.bathrooms, k2, k3, k4, k5)\n      MSE.Crsfld.bathrooms[j] <- mse_v(k1,lm.bathrooms)\n    }\n    if(j == 2){\n      lm.bathrooms <- f.lm.crossV(formula.bathrooms, k1, k3, k4, k5)\n      MSE.Crsfld.bathrooms[j] <- mse_v(k2,lm.bathrooms)\n    }\n    if(j == 3){\n      lm.bathrooms <- f.lm.crossV(formula.bathrooms, k1, k2, k4, k5)\n      MSE.Crsfld.bathrooms[j] <- mse_v(k3,lm.bathrooms)\n    }\n    if(j == 4){\n      lm.bathrooms <- f.lm.crossV(formula.bathrooms, k1, k2, k3, k5)\n      MSE.Crsfld.bathrooms[j] <- mse_v(k4,lm.bathrooms)\n    }\n    if(j == 5){\n      lm.bathrooms <- f.lm.crossV(formula.bathrooms, k1, k2, k3, k4)\n      MSE.Crsfld.bathrooms[j] <- mse_v(k5,lm.bathrooms)\n    }\n  }\n  MSE.Ply.bathrooms[i] <- mean(MSE.Crsfld.bathrooms)\n}\n#View(MSE.Ply.bathrooms)\n#Plot of the MSE for \"bathrooms\"\nplot(order,MSE.Ply.bathrooms, type = \"o\", col = \"chocolate1\", lwd = 2, main = \"5-fold CV - Bathrooms\", xlab = \"Degree of Polynomial\", ylab = \"Mean Squared Error\")\n\n\n#-------------------------------------------------------------------------------------sqft_above\n#vector to save the MSE of each cross fold validation for each polynomial of \"sqft_above\"\nMSE.Crsfld.sqft_above <- c(0,0,0,0,0)\n\n#vector to save the MSE of each polynomial for \"sqft_above\"\nMSE.Ply.sqft_above <- c(0,0,0,0,0)\n\n#---------------------------------------------------\n# For loop to perform iteratively cross validation for \"sqft_above\" \n# In the first loop, selection of the formula (polynomial) is achieved. In the nested\n# for loop cross validation and MSE of each test set is obtained and saved\n# in MSE.Crsfld.sqft_above vector, subsequently the mean of this variable is stored in\n# MSE.Ply.sqft_above this is for each polynomial.\n\nfor(i in 1:5){\n  formula.sqft_above <- lm(price ~. - floors - sqft_basement + poly(sqft_above, i), data=houseData)\n  for(j in 1:5){\n    if(j == 1){\n      lm.sqft_above <- f.lm.crossV(formula.sqft_above, k2, k3, k4, k5)\n      MSE.Crsfld.sqft_above[j] <- mse_v(k1,lm.sqft_above)\n    }\n    if(j == 2){\n      lm.sqft_above <- f.lm.crossV(formula.sqft_above, k1, k3, k4, k5)\n      MSE.Crsfld.sqft_above[j] <- mse_v(k2,lm.sqft_above)\n    }\n    if(j == 3){\n      lm.sqft_above <- f.lm.crossV(formula.sqft_above, k1, k2, k4, k5)\n      MSE.Crsfld.sqft_above[j] <- mse_v(k3,lm.sqft_above)\n    }\n    if(j == 4){\n      lm.sqft_above <- f.lm.crossV(formula.sqft_above, k1, k2, k3, k5)\n      MSE.Crsfld.sqft_above[j] <- mse_v(k4,lm.sqft_above)\n    }\n    if(j == 5){\n      lm.sqft_above <- f.lm.crossV(formula.sqft_above, k1, k2, k3, k4)\n      MSE.Crsfld.sqft_above[j] <- mse_v(k5,lm.sqft_above)\n    }\n  }\n  MSE.Ply.sqft_above[i] <- mean(MSE.Crsfld.sqft_above)\n}\n#View(MSE.Ply.sqft_above)\n#Plot of the MSE for \"sqft_above\"\nplot(order,MSE.Ply.sqft_above, type = \"o\",  col = \"forestgreen\", lwd = 2, main = \"5-fold CV - sqft_above\", xlab = \"Degree of Polynomial\", ylab = \"Mean Squared Error\")\n\n\n\n",
    "created" : 1478014259410.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3211292899",
    "id" : "A2A43ACF",
    "lastKnownWriteTime" : 1478375930,
    "last_content_update" : 1478375930683,
    "path" : "~/JACOBS/Primer semestre/Principles of Statistical Modeling/Miniquiz-3/PSM_MQ_3/MQ3.R",
    "project_path" : "MQ3.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}